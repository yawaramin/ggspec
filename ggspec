#!/usr/bin/guile \
-e main -s
ggspec - run a set of test suites in your project's 'spec' subdirectory.

Copyright (c) 2014 Yawar Amin
GitHub, Reddit, Twitter: yawaramin

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
!#
(use-modules
  (srfi srfi-1)
  (ggspec lib)
  (ice-9 ftw)
  (ice-9 getopt-long)
  (ice-9 match))

(define (suite-add-option opt s)
  "Add an option to the read, unevaluated form of a suite.

  Arguments
    opt: '(option k v)

      k: symbol: name of the option.
      v: any; value of the option.

    s: form: a read, unevaluated 'suite' form:

      (suite desc tsts opts sups tdowns)

  Returns
    A read, unevaluated suite with the option added."
  (define (opts-add-opt os o)
    (cons 'options (cons o (cdr os))))

  #!
  Below, variable names have the following meanings:

  d: suite description
  ts: a list of tests
  os: a list of options
  ss: a list of setups
  tds: a list of teardowns
  !#
  (match s
    (('suite d ts) (list 'suite d ts (list 'options opt)))
    (('suite d ts os) (list 'suite d ts (opts-add-opt os opt)))
    (('suite d ts os ss) (list 'suite d ts (opts-add-opt os opt) ss))
    (('suite d ts os ss tds)
      (list 'suite d ts (opts-add-opt os opt) ss tds))))

(define (run-file fname opts)
  "Run all test suites found in the given file, and aggregate and return
  the number of passed and failed tests.

  Arguments
    fname: string: the name of the file to look in for test suites.

  Returns
    (list num-passes num-fails): same as in the suite function."
  (call-with-input-file
    fname
    (lambda (f)
      (let loop
        ((form (read f))
        (num-passes 0)
        (num-fails 0)
        (num-skips 0))

        (cond
          ((eof-object? form)
            (list num-passes num-fails num-skips))
          ((equal? (car form) 'suite)
            ;; Add options to the current suite and run it.
            (let
              ((results
                (eval
                  (fold suite-add-option form opts)
                  (current-module))))

              (loop
                (read f)
                (+ num-passes (car results))
                (+ num-fails (cadr results))
                (+ num-skips (caddr results)))))
          (#t
            ;; This is some form other than a suite definition.
            (begin
              (eval form (current-module))
              ;; Go on to the next form, with results unchanged.
              (loop (read f) num-passes num-fails num-skips))))))))

(define (run-tree dname opts)
  "Run all test suites found in files in the given directory and all its
  subdirectories, and aggregate and return the number of passed and
  failed tests.

  Arguments
    dname: string: the name of the directory to look in for test
    suites."
  (define (up-down-skip path stat result) result)
  (file-system-fold
    (stub #t)
    (lambda (path stat result)
      (define path-length (string-length path))

      (if (equal? (substring path (- path-length 4)) ".scm")
        (let ((file-result (run-file path opts)))
          (list
            (+ (car result) (car file-result))
            (+ (cadr result) (cadr file-result))
            (+ (caddr result) (caddr file-result))))))
    up-down-skip
    up-down-skip
    up-down-skip
    (lambda (path stat errno result) result)
    (list 0 0 0) ; Seed value of result: passes fails skips
    dname))

(define (main args)
  (define cmd-line-opts
    (getopt-long
      args
      '((version (single-char #\v) (value #f))
      (help (single-char #\h) (value #f))
      (colour (single-char #\c) (value #f))
      (format (single-char #\f) (value #t)))))
  (define output-cb (option-ref cmd-line-opts 'format "normal"))
  (define colour (option-ref cmd-line-opts 'colour #f))

  (define opts
    (list
      `(option
        'output-cb
        ,(cond
          ((equal? output-cb "normal") output-normal)
          ((equal? output-cb "tap") output-tap)
          (#t output-none)))
      `(option 'colour ,colour)))
  (define result (run-tree "spec" opts))
  (define total (apply + result))

  #!
  TODO: move the result printing into the output-cb functions, e.g.
  like:

  (output-cb
    #:tally-passed passed
    #:tally-failed failed
    #:tally-skipped skipped)
  !#
  (cond
    ((equal? output-cb "normal")
      (println
        "Total "
        total
        ", passed "
        (car result)
        ", failed "
        (cadr result)
        ", skipped "
        (caddr result)
        "."))
    ((equal? output-cb "tap")
      (println "1.." total))))

;; vim:set ft=scheme:

